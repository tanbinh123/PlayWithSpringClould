# 发问：

项目中缓存是如何使用的？为什么要用缓存？缓存使用不当会造成什么后果？

# 为什么用缓存？

使用缓存主要有两个用途：高性能、高并发（因位缓存的读写速度快，内存天然支撑高并发）

MySQL 单机支撑到 2000QPS 开始报警了，而缓存单机支撑的并发量轻松一秒几万十几万。

# 如何保证缓存与数据库的双写一致性？

**读请求和写请求串行化**，串到一个内存队列里去。串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低。

**Cache Aside Pattern**：最经典的缓存+数据库读写的模式
- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存。（先删除缓存，然后更新数据库）

这里更新的时候先更新数据库，然后删除缓存，为什么是删除缓存而不是更新缓存呢？

首先缓存的应用场景可能不止使用一张表的数据，而是关联计算出来的值。
其次缓存应该是**需要用到的缓存才去计算缓存**，这也是缓存的价值所在：热点数据才需要被缓存

# redis 的雪崩、穿透和击穿

**缓存雪崩**：

缓存机器意外发生了全盘宕机。缓存挂了，此时所有的请求都落到了数据库上，数据库扛不住，他就会报警，然后就挂了，此时，如果没有采用什么特别的
方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是**缓存雪崩**。

缓存雪崩的事前事中事后的解决方案如下。

- 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
- 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。

**缓存穿透**：

对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。

黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。

举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

解决方案可以将不存在的数据也缓存起来，即存储一个 value 为 null 的键值对

**缓存击穿**：

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。


# redis 的并发竞争问题是什么？如何解决这个问题？了解 redis 事务的 CAS 方案吗？

可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。

# redis 的过期策略

定期删除 + 惰性删除
定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
惰性删除，是指获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。

内存淘汰机制：
- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

